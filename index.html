<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>快手咖啡师</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'PingFang SC', 'Helvetica Neue', Arial, sans-serif;
            background-color: #F5E6D8;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #6B4226;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #F5E6D8;
            text-align: center;
            padding: 20px;
        }
        
        #title-screen h1 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #title-screen p {
            font-size: 16px;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        #start-btn {
            margin-top: 40px;
            padding: 15px 30px;
            font-size: 20px;
            background-color: #E3A868;
            color: #6B4226;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        #start-btn:active {
            transform: translateY(4px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        #game-interface {
            display: none;
            flex: 1;
            flex-direction: column;
        }
        
        #info-panel {
            background-color: #6B4226;
            color: #F5E6D8;
            padding: 10px;
            text-align: center;
            position: relative;
        }
        
        #timer {
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 5px;
        }
        
        #timer-progress {
            width: 60%;
            height: 10px;
            background-color: #8C593A;
            border-radius: 5px;
            margin-left: 10px;
            overflow: hidden;
        }
        
        #timer-bar {
            height: 100%;
            background-color: #E3A868;
            width: 100%;
            transition: width 1s linear;
        }
        
        #customer-count {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 14px;
        }
        
        #recipe-hint {
            background-color: #E3A868;
            color: #6B4226;
            padding: 5px;
            font-size: 14px;
            text-align: center;
        }
        
        #all-recipes {
            background-color: #F5E6D8;
            border-top: 1px solid #E3A868;
            border-bottom: 1px solid #E3A868;
            padding: 8px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            overflow-x: auto;
            white-space: nowrap;
        }
        
        .recipe-card {
            background-color: white;
            border: 1px solid #E3A868;
            border-radius: 5px;
            padding: 5px 8px;
            margin-right: 8px;
            flex-shrink: 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .recipe-card:last-child {
            margin-right: 0;
        }
        
        .recipe-name {
            font-weight: bold;
            color: #6B4226;
            margin-bottom: 3px;
            text-align: center;
        }
        
        .recipe-ingredients {
            color: #8C593A;
            font-size: 11px;
        }
        
        #customer-interaction {
            display: flex;
            padding: 10px;
            align-items: center;
            background-color: #F5E6D8;
            border-bottom: 1px solid #E3A868;
        }
        
        #customer-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
            margin-right: 10px;
            border: 2px solid #6B4226;
            background-color: #DDD;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #speech-bubble {
            background-color: white;
            border-radius: 15px;
            padding: 10px;
            flex-grow: 1;
            font-size: 14px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            min-height: 60px; /* Ensure consistent height during typing animation */
        }
        
        #speech-bubble:before {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            border-width: 10px 10px 10px 0;
            border-style: solid;
            border-color: transparent white transparent transparent;
        }
        
        #coffee-display {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 20px;
            background-color: #F5E6D8;
            overflow: hidden;
        }
        
        #coffee-cup {
            width: 160px;
            height: 240px;
            background-color: #fff;
            border-radius: 10px 10px 70px 70px;
            position: relative;
            border: 5px solid #DDD;
            overflow: hidden;
        }
        
        /* 添加不同尺寸的咖啡杯样式 */
        .cup-small {
            width: 160px !important;
            height: 120px !important;
        }
        
        .cup-medium {
            width: 160px !important;
            height: 180px !important;
        }
        
        .cup-large {
            width: 160px !important;
            height: 240px !important;
        }
        
        /* 添加容量指示器 */
        .capacity-indicator {
            position: absolute;
            right: -40px;
            height: 100%;
            width: 10px;
            background-color: #DDD;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .capacity-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background-color: #E3A868;
            transition: height 0.3s ease;
        }
        
        .capacity-marker {
            position: absolute;
            width: 100%;
            height: 2px;
            background-color: #6B4226;
            left: 0;
        }
        
        .capacity-label {
            position: absolute;
            right: -35px;
            font-size: 10px;
            color: #6B4226;
            background-color: #F5E6D8;
            padding: 1px 3px;
            border-radius: 2px;
            transform: translateY(-50%);
        }
        
        .cup-enter {
            transform: translateX(200%);
            transition: transform 0.5s ease-in-out;
        }
        
        .cup-exit {
            transform: translateX(-200%);
            transition: transform 0.5s ease-in-out;
        }
        
        /* 添加一个新的类用于立即重置杯子位置（无动画） */
        .cup-reset {
            transform: translateX(200%);
            transition: none !important;
        }
        
        .liquid-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0;
            transition: height 0.1s linear;
        }
        
        #overflow-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            display: none;
            z-index: 10;
        }
        
        #control-panel {
            background-color: #8C593A;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .ingredient-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .ingredient-btn {
            flex: 1;
            padding: 15px 0;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        
        .ingredient-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
        }
        
        #coffee-btn {
            background-color: #3C2415;
        }
        
        #milk-btn {
            background-color: #E8D4BE;
            color: #6B4226;
        }
        
        #water-btn {
            background-color: #A7C7E7;
            color: #2C4053;
        }
        
        #finish-btn {
            padding: 15px;
            font-size: 18px;
            background-color: #E3A868;
            color: #6B4226;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        
        #finish-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0, 0, 0, 0.2);
        }
        
        #results-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(107, 66, 38, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            color: #F5E6D8;
            text-align: center;
            padding: 20px;
        }
        
        #results-screen h2 {
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .score-detail {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        #total-score {
            font-size: 36px;
            font-weight: bold;
            margin: 20px 0;
            color: #E3A868;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #barista-title {
            font-size: 24px;
            margin-bottom: 30px;
            background-color: #E3A868;
            color: #6B4226;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        #play-again-btn {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #E3A868;
            color: #6B4226;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        #play-again-btn:active {
            transform: translateY(4px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        #feedback-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #6B4226;
            border: 3px solid #E3A868;
            border-radius: 15px;
            padding: 20px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 60;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 80%;
            max-width: 300px;
        }
        
        #feedback-message {
            font-size: 20px;
            color: #F5E6D8;
            text-align: center;
            margin-bottom: 15px;
        }
        
        #feedback-score {
            font-size: 24px;
            font-weight: bold;
            color: #E3A868;
            margin-bottom: 15px;
        }
        
        #feedback-details {
            font-size: 14px;
            color: #F5E6D8;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #continue-btn {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #E3A868;
            color: #6B4226;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        /* Add styles for the title progression chart */
        #title-chart {
            width: 90%;
            max-width: 400px;
            height: 40px;
            background-color: #8C593A;
            border-radius: 20px;
            margin: 15px 0 25px;
            position: relative;
            display: flex;
            justify-content: space-between;
        }
        
        .title-section {
            flex: 1;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border-right: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .title-section:last-child {
            border-right: none;
        }
        
        .title-section.active {
            background-color: #E3A868;
            color: #6B4226;
            font-weight: bold;
        }
        
        .title-section:first-child {
            border-radius: 20px 0 0 20px;
        }
        
        .title-section:last-child {
            border-radius: 0 20px 20px 0;
        }
        
        .title-marker {
            position: absolute;
            top: -25px;
            transform: translateX(-50%);
            color: #F5E6D8;
            font-size: 12px;
            text-align: center;
            width: 80px;
            left: 50%;
        }
        
        #player-marker {
            position: absolute;
            bottom: -15px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 12px solid white;
            transform: translateX(-50%);
        }
        
        .typing-cursor {
            display: inline-block;
            width: 2px;
            height: 14px;
            background-color: #6B4226;
            margin-left: 2px;
            animation: blink 0.7s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        /* 添加液体排空动画 */
        @keyframes drain-liquid {
            0% { height: var(--initial-height); }
            100% { height: 0%; }
        }
        
        .draining {
            animation: drain-liquid var(--drain-duration) linear forwards;
        }
        
        /* 移除之前的延迟类，因为我们将使用动态计算的延迟 */
        .draining-delay-1, .draining-delay-2, .draining-delay-3, .draining-delay-4, .draining-delay-5 {
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="title-screen">
            <h1>快手咖啡师</h1>
            <p>游戏规则：</p>
            <p>根据客人订单要求，通过精准控制原料顺序、比例和时间，调制出符合标准的咖啡。</p>
            <p>长按原料按键注入，松开停止。点击完成按钮结束调制。</p>
            <p>所有咖啡配方将常驻显示，请根据客人对话内容判断所需咖啡类型。</p>
            <button id="start-btn">开始游戏</button>
        </div>
        
        <div id="game-interface">
            <div id="info-panel">
                <div id="timer">
                    剩余时间: <span id="timer-text">30</span>秒
                    <div id="timer-progress">
                        <div id="timer-bar"></div>
                    </div>
                </div>
                <div id="customer-count">客人: 0/5</div>
            </div>
            
            <div id="customer-interaction">
                <div id="customer-avatar">
                    <!-- 客人头像会在这里显示 -->
                </div>
                <div id="speech-bubble">
                    <!-- 客人对白会在这里显示 -->
                </div>
            </div>
            
            <div id="recipe-hint"></div>
            
            <div id="all-recipes">
                <!-- 所有咖啡配方会在这里显示 -->
            </div>
            
            <div id="coffee-display">
                <div id="overflow-message">咖啡溢出!</div>
                <div id="coffee-cup">
                    <!-- 液体层会在这里动态生成 -->
                </div>
            </div>
            
            <div id="control-panel">
                <div class="ingredient-buttons">
                    <button id="coffee-btn" class="ingredient-btn">咖啡</button>
                    <button id="milk-btn" class="ingredient-btn">牛奶</button>
                    <button id="water-btn" class="ingredient-btn">水</button>
                </div>
                <button id="finish-btn">完成</button>
            </div>
        </div>
        
        <div id="feedback-container">
            <div id="feedback-message">调制完成!</div>
            <div id="feedback-score">0分</div>
            <div id="feedback-details"></div>
            <button id="continue-btn">继续</button>
        </div>
        
        <div id="results-screen">
            <h2>游戏结束</h2>
            <div id="order-accuracy" class="score-detail">订单准确性: 0%</div>
            <div id="proportion-accuracy" class="score-detail">比例精确度: 0%</div>
            <div id="time-efficiency" class="score-detail">时间效率: 0%</div>
            <div id="total-score">总分: 0</div>
            <div id="barista-title">咖啡学徒</div>
            
            <!-- Add title progression chart -->
            <div id="title-chart">
                <div class="title-section" id="title-section-1">
                    <div class="title-marker">咖啡小白<br>0-149</div>
                </div>
                <div class="title-section" id="title-section-2">
                    <div class="title-marker">咖啡学徒<br>150-249</div>
                </div>
                <div class="title-section" id="title-section-3">
                    <div class="title-marker">咖啡师<br>250-349</div>
                </div>
                <div class="title-section" id="title-section-4">
                    <div class="title-marker">资深咖啡师<br>350-449</div>
                </div>
                <div class="title-section" id="title-section-5">
                    <div class="title-marker">咖啡大师<br>450+</div>
                </div>
                <div id="player-marker"></div>
            </div>
            
            <button id="play-again-btn">再来一局</button>
        </div>
    </div>

    <script>
        // 咖啡配方定义
        const RECIPES = {
            latte: {
                name: "拿铁",
                ingredients: [
                    { type: "coffee", ratio: 0.3 },
                    { type: "milk", ratio: 0.7 }
                ],
                description: "30%咖啡 + 70%牛奶",
                orderDialogues: [
                    "一杯香浓的拿铁，请不要太甜。",
                    "早安，我想来杯拿铁提提神。",
                    "拿铁加多一点奶泡，谢谢。",
                    "拿铁是我的心头好，麻烦来一杯。",
                    "忙碌的一天，来杯拿铁缓解疲劳。",
                    "我想要尝试你们店里最好的拿铁。",
                    "天气有点冷，来杯热拿铁暖暖身子。",
                    "上次喝的拿铁很棒，再来一杯。",
                    "听说你们的拿铁很有名，给我来一杯。",
                    "不加糖的拿铁，咖啡和牛奶的完美融合。"
                ]
            },
            americano: {
                name: "美式",
                ingredients: [
                    { type: "coffee", ratio: 0.5 },
                    { type: "water", ratio: 0.5 }
                ],
                description: "50%咖啡 + 50%水",
                orderDialogues: [
                    "来杯醇厚的美式咖啡，不加糖。",
                    "美式咖啡，提神又解乏。",
                    "赶稿子中，需要一杯浓郁的美式。",
                    "简单的美式咖啡最能体现咖啡的本质。",
                    "我每天都要喝一杯美式，成了习惯。",
                    "美式咖啡，越浓越好。",
                    "加班熬夜，来杯美式提神。",
                    "我喜欢原汁原味的美式咖啡。",
                    "一杯美式，简单纯粹。",
                    "你们的美式咖啡豆是哪里进口的？给我来一杯。"
                ]
            },
            flatWhite: {
                name: "澳白",
                ingredients: [
                    { type: "coffee", ratio: 0.3 },
                    { type: "milk", ratio: 0.4 },
                    { type: "coffee", ratio: 0.3 }
                ],
                description: "30%咖啡 + 40%牛奶 + 30%咖啡",
                orderDialogues: [
                    "来杯地道的澳白，注意咖啡和牛奶的层次感。",
                    "澳白是我的最爱，平滑又浓郁。",
                    "在悉尼喝过最好的澳白，你能做出相似的味道吗？",
                    "我对澳白的要求很高，希望你能调制得完美。",
                    "想尝尝正宗的澳白，听说你这里做得不错。",
                    "澳洲回来后就爱上了澳白的口感。",
                    "咖啡中的奢侈品，来杯澳白犒劳自己。",
                    "想念墨尔本咖啡馆的澳白，给我来一杯。",
                    "第一次尝试澳白，期待你的手艺。",
                    "澳白的双重咖啡层，是我的心头好。"
                ]
            },
            espresso: {
                name: "意式浓缩",
                ingredients: [
                    { type: "coffee", ratio: 0.7 }
                ],
                description: "70%咖啡",
                orderDialogues: [
                    "一杯意式浓缩，要纯正的意式风味。",
                    "需要意式浓缩咖啡的强劲提神效果。",
                    "来一杯意式浓缩，不加任何东西。",
                    "真正的咖啡爱好者只喝意式浓缩。",
                    "一杯好的意式浓缩应该有完美的咖啡油脂层。",
                    "意大利人教我欣赏意式浓缩咖啡的精髓。",
                    "我只喝意式浓缩，最纯粹的咖啡体验。",
                    "测试咖啡师水平，就是看他的意式浓缩做得怎么样。",
                    "下午需要一剂咖啡因，意式浓缩最适合。",
                    "罗马假日的早晨，总是从一杯意式浓缩开始。"
                ]
            }
        };

        // 原料颜色
        const INGREDIENT_COLORS = {
            coffee: "#3C2415",
            milk: "#E8D4BE",
            water: "#A7C7E7"
        };

        // 客人头像SVG数据
        const CUSTOMER_AVATARS = [
            // 商务人士
            `<svg viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
                <rect width="60" height="60" fill="#EFEFEF"/>
                <circle cx="30" cy="20" r="12" fill="#333"/>
                <rect x="18" y="25" width="24" height="30" fill="#333"/>
                <rect x="22" y="25" width="16" height="8" fill="#666"/>
            </svg>`,
            
            // 年轻女性
            `<svg viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
                <rect width="60" height="60" fill="#EFEFEF"/>
                <circle cx="30" cy="20" r="12" fill="#F06292"/>
                <path d="M18,28 C18,20 42,20 42,28 L42,50 L18,50 Z" fill="#F06292"/>
                <path d="M30,20 C25,20 22,24 22,28 L38,28 C38,24 35,20 30,20 Z" fill="#E91E63"/>
            </svg>`,
            
            // 老年人
            `<svg viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
                <rect width="60" height="60" fill="#EFEFEF"/>
                <circle cx="30" cy="20" r="12" fill="#CCC"/>
                <rect x="18" y="25" width="24" height="30" fill="#607D8B"/>
                <rect x="24" y="25" width="12" height="5" fill="#FFF"/>
                <path d="M30,30 C28,40 32,40 30,50" stroke="#455A64" stroke-width="2" fill="none"/>
            </svg>`,
            
            // 学生
            `<svg viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
                <rect width="60" height="60" fill="#EFEFEF"/>
                <circle cx="30" cy="20" r="12" fill="#333"/>
                <rect x="18" y="25" width="24" height="30" fill="#2196F3"/>
                <rect x="20" y="35" width="20" height="6" fill="#FFF"/>
            </svg>`,
            
            // 艺术家
            `<svg viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
                <rect width="60" height="60" fill="#EFEFEF"/>
                <circle cx="30" cy="20" r="12" fill="#333"/>
                <rect x="18" y="25" width="24" height="30" fill="#673AB7"/>
                <ellipse cx="30" cy="15" rx="15" ry="3" fill="#333"/>
            </svg>`
        ];

        // 客人评价对白
        const CUSTOMER_FEEDBACK = {
            good: [
                "这杯咖啡太棒了！香醇浓郁，比例刚刚好。",
                "完美！这就是我想要的味道，你的手艺真不错。",
                "啊，这杯咖啡让我的一天都明亮起来了。谢谢！",
                "咖啡的温度和口感都恰到好处，真是享受。",
                "我得说，这可能是我喝过的最好的咖啡之一。"
            ],
            average: [
                "嗯...还行吧，但似乎比例不太对。",
                "味道可以接受，但我期待的更好一些。",
                "不算太差，但也没什么特别的。",
                "差不多吧，下次可以再调整一下。",
                "勉强能喝，但离完美还有距离。"
            ],
            bad: [
                "这是什么味道？完全不是我点的咖啡。",
                "嗯...抱歉，这实在太难喝了。",
                "比例完全错了，这根本不是我想要的。",
                "我想你需要重新学习如何制作咖啡...",
                "啊，太糟糕了，我甚至不想喝第二口。"
            ],
            overflow: [
                // 商务人士 - 0
                "这太不专业了！我要投诉给你们经理。",
                // 年轻女性 - 1
                "啊！我的新衣服！这下可怎么办...",
                // 老年人 - 2
                "哎呀！年轻人做事怎么这么毛躁？",
                // 学生 - 3
                "哇！好刺激！不过我的笔记本都湿了...",
                // 艺术家 - 4
                "嗯...这倒是一种有趣的艺术表现形式，但不是我要的咖啡。"
            ]
        };

        // 游戏状态
        let gameState = {
            isPlaying: false,
            currentOrder: null,
            currentCustomer: 0,
            currentCustomerType: 0,
            maxCustomers: 5,
            timeLeft: 30,
            timer: null,
            cupCapacity: 100, // 定义杯子容量单位
            currentLayers: [],
            ingredientHistory: [],
            scores: [],
            currentCupSize: 'medium', // 当前杯子尺寸
            cupSizeCapacity: {
                small: 30,  // 小杯容量为30%
                medium: 60, // 中杯容量为60%
                large: 100  // 大杯容量为100%
            },
            scoreDetails: {
                orderAccuracy: 0,
                proportionAccuracy: 0,
                timeEfficiency: 0
            }
        };

        // DOM 元素
        const titleScreen = document.getElementById('title-screen');
        const gameInterface = document.getElementById('game-interface');
        const resultsScreen = document.getElementById('results-screen');
        const startBtn = document.getElementById('start-btn');
        const playAgainBtn = document.getElementById('play-again-btn');
        const recipeHint = document.getElementById('recipe-hint');
        const timerEl = document.getElementById('timer');
        const customerCount = document.getElementById('customer-count');
        const coffeeBtn = document.getElementById('coffee-btn');
        const milkBtn = document.getElementById('milk-btn');
        const waterBtn = document.getElementById('water-btn');
        const finishBtn = document.getElementById('finish-btn');
        const coffeeCup = document.getElementById('coffee-cup');
        const feedbackContainer = document.getElementById('feedback-container');
        const feedbackMessage = document.getElementById('feedback-message');
        const feedbackScore = document.getElementById('feedback-score');
        const feedbackDetails = document.getElementById('feedback-details');
        const continueBtn = document.getElementById('continue-btn');
        const customerAvatar = document.getElementById('customer-avatar');
        const speechBubble = document.getElementById('speech-bubble');

        // 设置倒入速度（毫秒/百分比）
        const POURING_SPEEDS = {
            coffee: 50, // 每50毫秒增加1%高度
            milk: 20,   // 每20毫秒增加1%高度
            water: 10   // 每10毫秒增加1%高度
        };

        // 显示所有配方
        function displayAllRecipes() {
            const allRecipesContainer = document.getElementById('all-recipes');
            allRecipesContainer.innerHTML = '';
            
            for (const key in RECIPES) {
                const recipe = RECIPES[key];
                const recipeCard = document.createElement('div');
                recipeCard.className = 'recipe-card';
                
                const recipeName = document.createElement('div');
                recipeName.className = 'recipe-name';
                recipeName.textContent = recipe.name;
                
                const recipeIngredients = document.createElement('div');
                recipeIngredients.className = 'recipe-ingredients';
                recipeIngredients.textContent = recipe.description;
                
                recipeCard.appendChild(recipeName);
                recipeCard.appendChild(recipeIngredients);
                allRecipesContainer.appendChild(recipeCard);
            }
        }

        // 游戏初始化
        function initGame() {
            gameState = {
                isPlaying: true,
                currentOrder: null,
                currentCustomer: 0,
                currentCustomerType: 0,
                maxCustomers: 5,
                timeLeft: 30,
                timer: null,
                cupCapacity: 100,
                currentLayers: [],
                ingredientHistory: [],
                scores: [],
                currentCupSize: 'medium',
                cupSizeCapacity: {
                    small: 30,
                    medium: 60,
                    large: 100
                },
                scoreDetails: {
                    orderAccuracy: 0,
                    proportionAccuracy: 0,
                    timeEfficiency: 0
                }
            };
            
            // 显示所有配方
            displayAllRecipes();
            
            // 重置杯子
            resetCup();
            
            // 生成第一个订单
            gameState.currentCustomer = 1;
            gameState.currentOrder = getRandomOrder();
            gameState.currentCustomerType = Math.floor(Math.random() * CUSTOMER_AVATARS.length);
            
            // 设置客人头像
            customerAvatar.innerHTML = CUSTOMER_AVATARS[gameState.currentCustomerType];
            
            // 随机选择杯子尺寸
            const cupSizes = ['small', 'medium', 'large'];
            gameState.currentCupSize = cupSizes[Math.floor(Math.random() * cupSizes.length)];
            
            // 获取杯子元素并设置初始状态
            const coffeeCup = document.getElementById('coffee-cup');
            coffeeCup.className = `cup-${gameState.currentCupSize}`;
            coffeeCup.style.transform = 'translateX(200%)';
            coffeeCup.style.transition = 'none';
            
            // 添加容量指示器
            addCapacityIndicator(coffeeCup, gameState.cupSizeCapacity[gameState.currentCupSize]);
            
            // 更新配方提示
            let cupSizeText = '';
            switch(gameState.currentCupSize) {
                case 'small':
                    cupSizeText = '小杯 (30%)';
                    break;
                case 'medium':
                    cupSizeText = '中杯 (60%)';
                    break;
                case 'large':
                    cupSizeText = '大杯 (100%)';
                    break;
            }
            recipeHint.textContent = `新订单已到达 (${cupSizeText})，请仔细听取客人需求`;
            
            // 显示随机点单对白
            const randomDialogueIndex = Math.floor(Math.random() * gameState.currentOrder.orderDialogues.length);
            displayDialogue(gameState.currentOrder.orderDialogues[randomDialogueIndex]);
            
            // 更新客人计数
            customerCount.textContent = `客人: ${gameState.currentCustomer}/${gameState.maxCustomers}`;
            
            // 重置进度条
            const timerBar = document.getElementById('timer-bar');
            timerBar.style.width = '100%';
            timerBar.style.backgroundColor = '#E3A868';
            
            // 设置计时器
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            gameState.timer = setInterval(updateTimer, 1000);
            
            // 强制浏览器重排
            coffeeCup.offsetHeight;
            
            // 添加入场动画
            requestAnimationFrame(() => {
                coffeeCup.style.transition = 'transform 0.5s ease-in-out';
                coffeeCup.style.transform = 'translateX(0)';
            });
        }

        // 更新计时器
        function updateTimer() {
            gameState.timeLeft--;
            const timerText = document.getElementById('timer-text');
            timerText.textContent = gameState.timeLeft;
            
            // 更新进度条
            const timerBar = document.getElementById('timer-bar');
            const percentage = (gameState.timeLeft / 30) * 100;
            timerBar.style.width = `${percentage}%`;
            
            // 当时间少于10秒时，进度条变红
            if (gameState.timeLeft <= 10) {
                timerBar.style.backgroundColor = '#FF5252';
            } else {
                timerBar.style.backgroundColor = '#E3A868';
            }
            
            if (gameState.timeLeft <= 0) {
                evaluateCoffee(true); // 时间到，强制评估
            }
        }

        // 获取下一个随机订单
        function getRandomOrder() {
            const recipes = Object.keys(RECIPES);
            const randomIndex = Math.floor(Math.random() * recipes.length);
            return RECIPES[recipes[randomIndex]];
        }

        // 显示随机点单对白
        function displayDialogue(text) {
            const speechBubble = document.getElementById('speech-bubble');
            speechBubble.innerHTML = ''; // Clear previous text
            
            const cursor = document.createElement('span');
            cursor.className = 'typing-cursor';
            speechBubble.appendChild(cursor);
            
            let i = 0;
            const typingSpeed = 50; // milliseconds per character
            
            function typeNextChar() {
                if (i < text.length) {
                    // Insert the character before the cursor
                    speechBubble.insertBefore(document.createTextNode(text.charAt(i)), cursor);
                    i++;
                    setTimeout(typeNextChar, typingSpeed);
                }
            }
            
            typeNextChar();
        }

        // 处理下一位客人
        function nextCustomer() {
            gameState.currentCustomer++;
            
            if (gameState.currentCustomer > gameState.maxCustomers) {
                endGame();
                return;
            }
            
            // 先让当前杯子滑出（向左）
            const coffeeCup = document.getElementById('coffee-cup');
            coffeeCup.style.transition = 'transform 0.5s ease-in-out';
            coffeeCup.style.transform = 'translateX(-100%)';
            
            // 延迟重置杯子和设置新客人
            setTimeout(() => {
                // 重置杯子和计时器
                resetCup();
                gameState.timeLeft = 30;
                document.getElementById('timer-text').textContent = gameState.timeLeft;
                
                // 重置进度条
                const timerBar = document.getElementById('timer-bar');
                timerBar.style.width = '100%';
                timerBar.style.backgroundColor = '#E3A868';
                
                // 清除旧计时器并设置新计时器
                if (gameState.timer) {
                    clearInterval(gameState.timer);
                }
                gameState.timer = setInterval(updateTimer, 1000);
                
                // 随机选择客人类型
                gameState.currentCustomerType = Math.floor(Math.random() * CUSTOMER_AVATARS.length);
                
                // 设置客人头像
                customerAvatar.innerHTML = CUSTOMER_AVATARS[gameState.currentCustomerType];
                
                // 生成新订单
                gameState.currentOrder = getRandomOrder();
                
                // 随机选择杯子尺寸
                const cupSizes = ['small', 'medium', 'large'];
                gameState.currentCupSize = cupSizes[Math.floor(Math.random() * cupSizes.length)];
                
                // 应用杯子尺寸
                coffeeCup.className = `cup-${gameState.currentCupSize}`;
                
                // 立即将杯子移动到右侧（无动画）
                coffeeCup.style.transition = 'none';
                coffeeCup.style.transform = 'translateX(100%)';
                
                // 添加容量指示器
                addCapacityIndicator(coffeeCup, gameState.cupSizeCapacity[gameState.currentCupSize]);
                
                // 更新配方提示 - 添加杯子尺寸提示
                let cupSizeText = '';
                switch(gameState.currentCupSize) {
                    case 'small':
                        cupSizeText = '小杯 (30%)';
                        break;
                    case 'medium':
                        cupSizeText = '中杯 (60%)';
                        break;
                    case 'large':
                        cupSizeText = '大杯 (100%)';
                        break;
                }
                recipeHint.textContent = `新订单已到达 (${cupSizeText})，请仔细听取客人需求`;
                
                // 显示随机点单对白，使用打字效果
                const randomDialogueIndex = Math.floor(Math.random() * gameState.currentOrder.orderDialogues.length);
                displayDialogue(gameState.currentOrder.orderDialogues[randomDialogueIndex]);
                
                // 更新客人计数
                customerCount.textContent = `客人: ${gameState.currentCustomer}/${gameState.maxCustomers}`;
                
                // 隐藏溢出提示
                document.getElementById('overflow-message').style.display = 'none';
                
                // 强制浏览器重排
                coffeeCup.offsetHeight;
                
                // 添加入场动画
                requestAnimationFrame(() => {
                    coffeeCup.style.transition = 'transform 0.5s ease-in-out';
                    coffeeCup.style.transform = 'translateX(0)';
                });
            }, 500); // 等待杯子滑出动画完成
        }

        // 添加容量指示器
        function addCapacityIndicator(cup, capacity) {
            // 创建容量指示器容器
            const indicator = document.createElement('div');
            indicator.className = 'capacity-indicator';
            
            // 创建填充条
            const fill = document.createElement('div');
            fill.className = 'capacity-fill';
            fill.style.height = '0%';
            indicator.appendChild(fill);
            
            // 添加100%标记
            const marker100 = document.createElement('div');
            marker100.className = 'capacity-marker';
            marker100.style.bottom = '100%';
            indicator.appendChild(marker100);
            
            const label100 = document.createElement('div');
            label100.className = 'capacity-label';
            label100.textContent = '100%';
            label100.style.bottom = '100%';
            indicator.appendChild(label100);
            
            // 添加当前杯子容量标记
            if (capacity < 100) {
                const markerCapacity = document.createElement('div');
                markerCapacity.className = 'capacity-marker';
                markerCapacity.style.bottom = `${capacity}%`;
                indicator.appendChild(markerCapacity);
                
                const labelCapacity = document.createElement('div');
                labelCapacity.className = 'capacity-label';
                labelCapacity.textContent = `${capacity}%`;
                labelCapacity.style.bottom = `${capacity}%`;
                indicator.appendChild(labelCapacity);
            }
            
            // 将指示器添加到杯子旁边
            cup.parentNode.appendChild(indicator);
        }
        
        // 更新容量指示器
        function updateCapacityIndicator(height) {
            const indicator = document.querySelector('.capacity-fill');
            if (indicator) {
                // 计算填充百分比 - 基于当前杯子容量
                const currentCapacity = gameState.cupSizeCapacity[gameState.currentCupSize];
                const fillPercentage = (height / currentCapacity) * 100;
                // 限制最大值为100%
                const cappedPercentage = Math.min(fillPercentage, 100);
                indicator.style.height = `${cappedPercentage}%`;
            }
        }

        // 重置咖啡杯
        function resetCup() {
            // 清除杯子中的所有层
            while (coffeeCup.firstChild) {
                coffeeCup.removeChild(coffeeCup.firstChild);
            }
            
            // 移除容量指示器
            const indicator = document.querySelector('.capacity-indicator');
            if (indicator) {
                indicator.parentNode.removeChild(indicator);
            }
            
            // 重置杯子动画和样式，但保留尺寸类
            coffeeCup.style.animation = '';
            
            gameState.currentLayers = [];
            gameState.ingredientHistory = [];
        }

        // 添加原料层
        function addIngredientLayer(type, height) {
            // 获取当前杯子的容量上限
            const currentCapacity = gameState.cupSizeCapacity[gameState.currentCupSize];
            
            const layer = document.createElement('div');
            layer.className = 'liquid-layer';
            layer.style.backgroundColor = INGREDIENT_COLORS[type];
            
            // 将实际高度映射到视觉高度
            const visualHeight = (height / currentCapacity) * 100;
            layer.style.height = `${visualHeight}%`;
            
            // 计算层的底部位置
            let bottomPosition = 0;
            gameState.currentLayers.forEach(existingLayer => {
                bottomPosition += existingLayer.height;
            });
            
            // 将实际底部位置映射到视觉底部位置
            const visualBottom = (bottomPosition / currentCapacity) * 100;
            layer.style.bottom = `${visualBottom}%`;
            
            // 将层添加到杯子中
            coffeeCup.appendChild(layer);
            
            // 更新当前层数组
            gameState.currentLayers.push({
                type: type,
                height: height
            });
            
            // 更新原料历史
            gameState.ingredientHistory.push({
                type: type,
                ratio: height / 100
            });
        }

        // 评估咖啡
        function evaluateCoffee(isTimeout = false) {
            clearInterval(gameState.timer);
            
            // 计算总高度
            let totalHeight = 0;
            gameState.currentLayers.forEach(layer => {
                totalHeight += layer.height;
            });
            
            // 检查杯子是否为空
            if (totalHeight === 0) {
                showFeedback("杯子是空的!", 0, "请添加原料后再完成。");
                return;
            }
            
            // 添加液体排空动画，按照后进先出的顺序
            const liquidLayers = Array.from(coffeeCup.querySelectorAll('.liquid-layer'));
            liquidLayers.reverse();
            
            // 计算每个层的动画延迟和持续时间
            const TOTAL_ANIMATION_TIME = 500; // 总动画时间保持在500ms
            let currentDelay = 0;
            
            liquidLayers.forEach((layer, index) => {
                // 获取当前层的高度百分比
                const heightPercentage = parseFloat(layer.style.height);
                
                // 保存当前高度作为动画起始值
                layer.style.setProperty('--initial-height', layer.style.height);
                
                // 计算这个层的动画时间（基于其高度占总高度的比例）
                const layerDuration = (heightPercentage / 100) * TOTAL_ANIMATION_TIME;
                
                // 设置动画延迟和持续时间
                layer.style.setProperty('--drain-duration', `${layerDuration}ms`);
                layer.style.animationDelay = `${currentDelay}ms`;
                
                // 更新下一层的延迟时间
                currentDelay += layerDuration;
                
                // 添加排空动画类
                requestAnimationFrame(() => {
                    layer.classList.add('draining');
                });
            });
            
            // 等待所有动画完成后显示评分
            setTimeout(() => {
                // 计算顺序正确性评分
                let orderScore = calculateOrderScore();
                
                // 计算比例误差率评分
                let proportionScore = calculateProportionScore();
                
                // 计算时间评分
                let timeScore = calculateTimeScore(isTimeout);
                
                // 计算总分
                let totalScore = Math.floor((orderScore + proportionScore + timeScore) / 3);
                
                // 存储本次得分和各项指标得分
                gameState.scores.push({
                    total: totalScore,
                    order: orderScore,
                    proportion: proportionScore,
                    time: timeScore
                });
                
                // 根据总分显示客人评价
                let feedbackType;
                if (totalScore >= 70) {
                    feedbackType = "good";
                } else if (totalScore >= 40) {
                    feedbackType = "average";
                } else {
                    feedbackType = "bad";
                }
                
                // 随机选择相应类型的评价，并使用打字效果显示
                const feedbackArray = CUSTOMER_FEEDBACK[feedbackType];
                const randomFeedbackIndex = Math.floor(Math.random() * feedbackArray.length);
                displayDialogue(feedbackArray[randomFeedbackIndex]);
                
                // 显示反馈
                const feedbackMsg = getFeedbackMessage(totalScore);
                showFeedback(
                    feedbackMsg, 
                    totalScore, 
                    `顺序: ${orderScore}分 | 比例: ${proportionScore}分 | 时间: ${timeScore}分`
                );
            }, TOTAL_ANIMATION_TIME);
        }

        // 计算顺序正确性评分
        function calculateOrderScore() {
            const expectedOrder = gameState.currentOrder.ingredients;
            const actualOrder = gameState.ingredientHistory;
            
            // 如果没有添加任何原料，得分为0
            if (actualOrder.length === 0) {
                return 0;
            }
            
            // 检查是否使用了所有必需的原料类型
            const expectedTypes = new Set();
            for (const item of expectedOrder) {
                expectedTypes.add(item.type);
            }
            
            const actualTypes = new Set();
            for (const item of actualOrder) {
                actualTypes.add(item.type);
            }
            
            // 检查是否所有期望的类型都被使用了
            for (const type of expectedTypes) {
                if (!actualTypes.has(type)) {
                    return 0; // 缺少必需的原料类型
                }
            }
            
            // 检查是否使用了额外的原料类型
            for (const type of actualTypes) {
                if (!expectedTypes.has(type)) {
                    return 0; // 使用了不需要的原料类型
                }
            }
            
            // 合并连续的相同类型原料
            const mergedActualOrder = [];
            let currentType = actualOrder[0].type;
            let currentRatio = actualOrder[0].ratio;
            
            for (let i = 1; i < actualOrder.length; i++) {
                if (actualOrder[i].type === currentType) {
                    // 如果类型相同，合并比例
                    currentRatio += actualOrder[i].ratio;
                } else {
                    // 如果类型不同，添加之前的合并结果并开始新的合并
                    mergedActualOrder.push({ type: currentType, ratio: currentRatio });
                    currentType = actualOrder[i].type;
                    currentRatio = actualOrder[i].ratio;
                }
            }
            // 添加最后一个合并结果
            mergedActualOrder.push({ type: currentType, ratio: currentRatio });
            
            // 如果合并后的原料数量与期望不符，得分降低但不为0
            if (mergedActualOrder.length !== expectedOrder.length) {
                return Math.max(30, 100 - Math.abs(mergedActualOrder.length - expectedOrder.length) * 20);
            }
            
            // 计算顺序正确性
            let correctCount = 0;
            for (let i = 0; i < expectedOrder.length; i++) {
                if (expectedOrder[i].type === mergedActualOrder[i].type) {
                    correctCount++;
                }
            }
            
            return Math.floor((correctCount / expectedOrder.length) * 100);
        }

        // 计算比例误差率评分
        function calculateProportionScore() {
            const expectedOrder = gameState.currentOrder.ingredients;
            const actualOrder = gameState.ingredientHistory;
            
            // 如果没有添加任何原料，得分为0
            if (actualOrder.length === 0) {
                return 0;
            }
            
            // 获取当前杯子的容量
            const currentCapacity = gameState.cupSizeCapacity[gameState.currentCupSize];
            
            // 计算配方的总比例（有些配方如意式浓缩可能不是100%）
            let recipeTotal = 0;
            for (const item of expectedOrder) {
                recipeTotal += item.ratio;
            }
            
            // 根据杯子容量调整期望的配方比例
            const scaleFactor = currentCapacity / 100;
            
            // 合并相同类型的原料
            const mergedActualOrder = [];
            const typesUsed = new Set();
            
            for (let i = 0; i < expectedOrder.length; i++) {
                const expectedType = expectedOrder[i].type;
                
                // 如果这个类型已经处理过，跳过
                if (typesUsed.has(expectedType)) continue;
                
                // 标记这个类型已处理
                typesUsed.add(expectedType);
                
                // 计算实际使用的该类型原料总比例
                let actualRatio = 0;
                for (let j = 0; j < actualOrder.length; j++) {
                    if (actualOrder[j].type === expectedType) {
                        actualRatio += actualOrder[j].ratio;
                    }
                }
                
                // 计算期望的该类型原料总比例（根据杯子容量调整）
                let expectedRatio = 0;
                for (let j = 0; j < expectedOrder.length; j++) {
                    if (expectedOrder[j].type === expectedType) {
                        expectedRatio += expectedOrder[j].ratio * scaleFactor;
                    }
                }
                
                // 添加到合并后的数组
                mergedActualOrder.push({
                    type: expectedType,
                    ratio: actualRatio,
                    expectedRatio: expectedRatio
                });
            }
            
            // 检查是否有多余的原料类型（不在配方中）
            const expectedTypes = new Set();
            for (const item of expectedOrder) {
                expectedTypes.add(item.type);
            }
            
            for (const item of actualOrder) {
                if (!expectedTypes.has(item.type)) {
                    // 如果使用了配方中没有的原料，得分为0
                    return 0;
                }
            }
            
            // 计算总实际比例（用于归一化）
            let totalActualRatio = 0;
            for (const item of mergedActualOrder) {
                totalActualRatio += item.ratio;
            }
            
            // 计算比例误差（如果总比例不为1，进行归一化）
            let totalError = 0;
            if (totalActualRatio > 0) {
                // 对于不是100%填满的配方（如意式浓缩），检查是否在合理范围内
                const adjustedRecipeTotal = recipeTotal * scaleFactor;
                if (Math.abs(totalActualRatio - adjustedRecipeTotal) > 0.1) {
                    // 如果总量差异太大，降低得分但不为0
                    const volumeError = Math.min(0.5, Math.abs(totalActualRatio - adjustedRecipeTotal) / adjustedRecipeTotal);
                    totalError += volumeError;
                }
                
                for (const item of mergedActualOrder) {
                    // 归一化实际比例（根据配方总比例）
                    const normalizedRatio = (item.ratio / totalActualRatio) * adjustedRecipeTotal;
                    const error = Math.abs(item.expectedRatio - normalizedRatio);
                    totalError += error;
                }
                
                // 平均误差（考虑了配方总量和各成分比例）
                totalError = totalError / (mergedActualOrder.length + 1);
            } else {
                return 0; // 如果总比例为0，得分为0
            }
            
            // 计算平均误差，并转换为得分（误差越小，分数越高）
            return Math.floor((1 - totalError) * 100);
        }

        // 计算时间评分
        function calculateTimeScore(isTimeout) {
            if (isTimeout) {
                return 0; // 超时得0分
            }
            
            // 基于剩余时间计算得分，满分30秒
            const timeFactor = gameState.timeLeft / 30;
            return Math.floor(timeFactor * 100);
        }

        // 获取反馈消息
        function getFeedbackMessage(score) {
            if (score >= 90) {
                return "完美！";
            } else if (score >= 70) {
                return "很好！";
            } else if (score >= 50) {
                return "还不错";
            } else if (score >= 30) {
                return "需要改进";
            } else {
                return "请继续努力";
            }
        }

        // 显示反馈
        function showFeedback(message, score, details) {
            feedbackMessage.textContent = message;
            feedbackScore.textContent = `${score}分`;
            feedbackDetails.textContent = details;
            feedbackContainer.style.display = "flex";
        }

        // 结束游戏
        function endGame() {
            gameState.isPlaying = false;
            clearInterval(gameState.timer);
            
            // 计算总分（所有客人得分的总和）
            const totalScore = gameState.scores.reduce((sum, score) => sum + score.total, 0);
            
            // 计算平均分（用于称号判断）
            const avgScore = Math.floor(totalScore / gameState.scores.length) || 0;
            
            // 计算各项指标的平均分
            const orderAccuracy = Math.floor(gameState.scores.reduce((sum, score) => sum + score.order, 0) / gameState.scores.length) || 0;
            const proportionAccuracy = Math.floor(gameState.scores.reduce((sum, score) => sum + score.proportion, 0) / gameState.scores.length) || 0;
            const timeEfficiency = Math.floor(gameState.scores.reduce((sum, score) => sum + score.time, 0) / gameState.scores.length) || 0;
            
            // 更新结果屏幕
            document.getElementById('order-accuracy').textContent = `订单准确性: ${orderAccuracy}%`;
            document.getElementById('proportion-accuracy').textContent = `比例精确度: ${proportionAccuracy}%`;
            document.getElementById('time-efficiency').textContent = `时间效率: ${timeEfficiency}%`;
            document.getElementById('total-score').textContent = `总分: ${totalScore}`;
            
            // 设置称号（基于总分而非平均分）
            let title = "";
            let titleSection = 1; // 默认为第一个称号
            
            if (totalScore >= 450) {
                title = "咖啡大师";
                titleSection = 5;
            } else if (totalScore >= 350) {
                title = "资深咖啡师";
                titleSection = 4;
            } else if (totalScore >= 250) {
                title = "咖啡师";
                titleSection = 3;
            } else if (totalScore >= 150) {
                title = "咖啡学徒";
                titleSection = 2;
            } else {
                title = "咖啡小白";
                titleSection = 1;
            }
            
            document.getElementById('barista-title').textContent = title;
            
            // 清除所有section的active类
            for (let i = 1; i <= 5; i++) {
                document.getElementById(`title-section-${i}`).classList.remove('active');
            }
            
            // 高亮当前称号
            document.getElementById(`title-section-${titleSection}`).classList.add('active');
            
            // 更精确地设置玩家标记位置
            let markerPosition;
            
            if (totalScore < 150) {
                // 0-149分范围内的线性映射
                const percentage = totalScore / 150;
                markerPosition = 10 + percentage * 20;
            } else if (totalScore < 250) {
                // 150-249分范围内的线性映射
                const percentage = (totalScore - 150) / 100;
                markerPosition = 30 + percentage * 20;
            } else if (totalScore < 350) {
                // 250-349分范围内的线性映射
                const percentage = (totalScore - 250) / 100;
                markerPosition = 50 + percentage * 20;
            } else if (totalScore < 450) {
                // 350-449分范围内的线性映射
                const percentage = (totalScore - 350) / 100;
                markerPosition = 70 + percentage * 20;
            } else {
                // 450分以上
                const percentage = Math.min((totalScore - 450) / 50, 1);
                markerPosition = 90 + percentage * 10;
                markerPosition = Math.min(markerPosition, 99); // 最高不超过99%
            }
            
            // 设置玩家标记位置
            document.getElementById('player-marker').style.left = `${markerPosition}%`;
            
            // 显示结果屏幕
            resultsScreen.style.display = "flex";
        }

        // 事件监听器
        startBtn.addEventListener('click', () => {
            titleScreen.style.display = "none";
            gameInterface.style.display = "flex";
            initGame();
        });

        playAgainBtn.addEventListener('click', () => {
            resultsScreen.style.display = "none";
            initGame();
        });

        continueBtn.addEventListener('click', () => {
            feedbackContainer.style.display = "none";
            nextCustomer();
        });

        // 原料按钮事件监听
        let isPouring = false;
        let currentIngredient = '';
        let pouringInterval = null;

        function startPouring(ingredient) {
            if (gameState.isPlaying && !isPouring) {
                isPouring = true;
                currentIngredient = ingredient;
                
                // 计算当前高度
                let currentHeight = 0;
                gameState.currentLayers.forEach(layer => {
                    currentHeight += layer.height;
                });
                
                // 获取当前杯子的容量上限
                const currentCapacity = gameState.cupSizeCapacity[gameState.currentCupSize];
                
                // 如果杯子满了，则不能再倒
                if (currentHeight >= currentCapacity) {
                    isPouring = false;
                    return;
                }
                
                // 创建新层
                const newLayer = document.createElement('div');
                newLayer.className = 'liquid-layer';
                newLayer.style.backgroundColor = INGREDIENT_COLORS[ingredient];
                newLayer.style.height = '0%';
                
                // 计算视觉上的底部位置 - 将实际高度映射到视觉高度
                const visualBottom = (currentHeight / currentCapacity) * 100;
                newLayer.style.bottom = `${visualBottom}%`;
                
                newLayer.dataset.pouring = 'true'; // 标记为正在倒入的层
                
                coffeeCup.appendChild(newLayer);
                
                // 开始倒入，根据原料类型设置不同的倒入速度
                let pouringHeight = 0;
                pouringInterval = setInterval(() => {
                    // 累计当前高度
                    let totalHeight = currentHeight + pouringHeight;
                    
                    // 更新容量指示器
                    updateCapacityIndicator(totalHeight);
                    
                    // 如果杯子满了，触发溢出事件
                    if (totalHeight >= currentCapacity) {
                        clearInterval(pouringInterval);
                        isPouring = false;
                        
                        // 计算视觉上的最终高度 - 将实际高度映射到视觉高度
                        const visualFinalHeight = ((currentCapacity - currentHeight) / currentCapacity) * 100;
                        newLayer.style.height = `${visualFinalHeight}%`;
                        newLayer.dataset.pouring = 'false';
                        
                        // 更新游戏状态
                        gameState.currentLayers.push({
                            type: ingredient,
                            height: currentCapacity - currentHeight
                        });
                        
                        gameState.ingredientHistory.push({
                            type: ingredient,
                            ratio: (currentCapacity - currentHeight) / 100
                        });
                        
                        // 触发溢出事件
                        handleCoffeeOverflow();
                        return;
                    }
                    
                    // 增加高度，并映射到视觉高度
                    pouringHeight += 1;
                    const visualHeight = (pouringHeight / currentCapacity) * 100;
                    newLayer.style.height = `${visualHeight}%`;
                    
                }, POURING_SPEEDS[ingredient]); // 根据原料类型使用不同的倒入速度
            }
        }

        function stopPouring() {
            if (isPouring) {
                clearInterval(pouringInterval);
                
                // 计算当前高度（不包括正在倒的层）
                let currentHeight = 0;
                gameState.currentLayers.forEach(layer => {
                    currentHeight += layer.height;
                });
                
                // 获取当前杯子的容量上限
                const currentCapacity = gameState.cupSizeCapacity[gameState.currentCupSize];
                
                // 获取最后一个层的高度（正在倒入的层）
                const lastLayer = coffeeCup.lastChild;
                if (lastLayer && lastLayer.dataset.pouring === 'true') {
                    // 从视觉高度转换回实际高度
                    const visualHeight = parseFloat(lastLayer.style.height);
                    const actualHeight = (visualHeight / 100) * currentCapacity;
                    
                    lastLayer.dataset.pouring = 'false'; // 标记为已完成倒入
                    
                    // 更新游戏状态
                    if (actualHeight > 0) {
                        gameState.currentLayers.push({
                            type: currentIngredient,
                            height: actualHeight
                        });
                        
                        gameState.ingredientHistory.push({
                            type: currentIngredient,
                            ratio: actualHeight / 100
                        });
                        
                        // 更新容量指示器
                        updateCapacityIndicator(currentHeight + actualHeight);
                    } else {
                        // 如果高度为0，移除这个层
                        coffeeCup.removeChild(lastLayer);
                    }
                }
                
                isPouring = false;
            }
        }

        // 触摸和鼠标事件
        coffeeBtn.addEventListener('mousedown', () => startPouring('coffee'));
        coffeeBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startPouring('coffee');
        });

        milkBtn.addEventListener('mousedown', () => startPouring('milk'));
        milkBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startPouring('milk');
        });

        waterBtn.addEventListener('mousedown', () => startPouring('water'));
        waterBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startPouring('water');
        });

        // 全局监听停止倒入事件
        document.addEventListener('mouseup', stopPouring);
        document.addEventListener('touchend', stopPouring);

        finishBtn.addEventListener('click', () => {
            if (gameState.isPlaying) {
                evaluateCoffee();
            }
        });

        // 处理咖啡溢出
        function handleCoffeeOverflow() {
            clearInterval(pouringInterval);
            clearInterval(gameState.timer);
            isPouring = false;
            
            // 显示溢出提示
            const overflowMessage = document.getElementById('overflow-message');
            overflowMessage.style.display = 'block';
            
            // 添加溢出动画效果，但不影响杯子尺寸
            const coffeeCup = document.getElementById('coffee-cup');
            coffeeCup.style.animation = 'shake 0.5s ease-in-out';
            
            // 确保杯子尺寸类仍然存在
            if (!coffeeCup.classList.contains(`cup-${gameState.currentCupSize}`)) {
                coffeeCup.classList.add(`cup-${gameState.currentCupSize}`);
            }
            
            // 评分为0
            const orderScore = 0;
            const proportionScore = 0;
            const timeScore = 0;
            const totalScore = 0;
            
            // 存储本次得分
            gameState.scores.push({
                total: totalScore,
                order: orderScore,
                proportion: proportionScore,
                time: timeScore
            });
            
            // 根据客人类型显示不同的溢出反馈，使用打字效果
            const overflowDialogue = CUSTOMER_FEEDBACK.overflow[gameState.currentCustomerType];
            displayDialogue(overflowDialogue);
            
            // 添加液体排空动画
            setTimeout(() => {
                const liquidLayers = Array.from(coffeeCup.querySelectorAll('.liquid-layer'));
                liquidLayers.reverse();
                
                // 计算每个层的动画延迟和持续时间
                const TOTAL_ANIMATION_TIME = 500; // 总动画时间保持在500ms
                let currentDelay = 0;
                
                liquidLayers.forEach((layer, index) => {
                    // 获取当前层的高度百分比
                    const heightPercentage = parseFloat(layer.style.height);
                    
                    // 保存当前高度作为动画起始值
                    layer.style.setProperty('--initial-height', layer.style.height);
                    
                    // 计算这个层的动画时间（基于其高度占总高度的比例）
                    const layerDuration = (heightPercentage / 100) * TOTAL_ANIMATION_TIME;
                    
                    // 设置动画延迟和持续时间
                    layer.style.setProperty('--drain-duration', `${layerDuration}ms`);
                    layer.style.animationDelay = `${currentDelay}ms`;
                    
                    // 更新下一层的延迟时间
                    currentDelay += layerDuration;
                    
                    // 添加排空动画类
                    requestAnimationFrame(() => {
                        layer.classList.add('draining');
                    });
                });
                
                // 延迟显示反馈，等待所有液体排空动画完成
                setTimeout(() => {
                    showFeedback(
                        "咖啡溢出!", 
                        totalScore, 
                        "请注意控制原料总量不超过100%"
                    );
                }, TOTAL_ANIMATION_TIME);
            }, 1000); // 等待摇晃动画完成后再开始排空
        }
    </script>


</body></html>